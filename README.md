Distinctiveness and Complexity
This project doesn't have anything in common with the previous projects, but the login/ register/ logout functions.

The project is based on a fitness club booking system, which allows users to view, book, join the waiting list and for admin users to create, update, book, and delete classes.
Simple user:
On the page, there is a “toggle menu” button which demonstrates the menu for navigation and a separate “header” menu button which lists options available to the user based on their access level (not logged in, logged in, teacher user, admin).
If the user isn’t logged in/ unregistered, they won’t see much, as it was designed to have the user logged in to view the web application. When a user registers an account (basic Django logic that was part of some of the projects previously). The user then has a default account that lets them choose a club of their choice. In this program there are 5 different clubs with their own unique timetables.
On the timetable page, the user gets to choose the club they want to see the timetable of. The timetable updates its entries based on the selected club. The design is Monday to Sunday weekdays and hours between 8 and 21. If there is a fitness class in the system for the allocated slot (weekday / time), then there will be a name of the class displayed (eg Pilates, Swimming), otherwise the square remains empty. If a user then clicks on one of the non-empty squares, the web app presents a popup with the details of the class (name, description, taught by, available capacity) and a book class and add to favourite’s button. If the user clicks book – they are then added to the class booking system and the page is refreshed (the capacity is then reduced by 1). The page refreshes and now on the same class, instead of book, there is a cancel button. Which when clicked, removes the user from the class and increases the available capacity by 1. The add to favourites button acts similarly, when clicked, the class is saved as a favourite class for the user and is available in their profile page to view. The page is then refreshed and when the same class is clicked, the user has the option to remove the class from favourites, which clicking the button does. Now if the class capacity is full and there are no slots available, if the user isn’t on the booked list for the class, they are then presented with the option to join the waiting list, instead of booking/ cancelling buttons. If the user clicks the button, they are then added to the waiting list, are assigned a waiting list que number and the que size is increased. If the user is in the que, they can leave the waiting list by clicking “leave “ button, which removes them from the list and updates the que order/ size.
On the profile page, the user has three options for bookings:
Upcoming – which when clicked, gives the user a list of classes that the user is booked into and are in the future. A table with entries of all the upcoming classes is displayed.
History – classes which the user took in the past and presents a table of those classes.
Favourites – a table of classes that the user saved into their favourites list.
On the booking page, the user can book themselves into a class in a different way. By selecting the club from the dropdown, the class dropdown is then populated with class options available in that club (excluding the classes that are fully booked). Once the user selects that class, the day dropdown is populated with the day options available for that class. And lastly same thing for time once a day is chosen. Once the user submits the booking, if the user isn’t booked in, they will be added to the booking list, but if the user is already booked in, they will get a message saying they’re already in the class.
The Events/ Careers/ Facility hire pages all bring the user to the “todo” page, which is a page that was planned to be another feature, but not this time. Currently it has a “check time” button, which runs three functions:
1)	Date_update – checks and updates the dates for the current timetable against the date and time now. This function, checks if the class timestamp is in the past and if so, creates a new class with the same details and empty capacity, deletes the old class and in doing so, removes all the associated entries of bookings, notifications, placeholders, waiting lists and st. This basically prunes the old classes and sets up a future class in the timetable, creating a new date and time stamp. The old class is then recorded in history for any user that was booked in.
2)	Placeholder_time_checker – checks if the future class is in 12h and if there are any placeholders occupying that class – deletes them and creates notifications for all users on the waiting list unless that user was already notified. However, the booking is also available to those outside the waiting list, as the class capacity is decreased, letting non waiting list users to swipe the slot.
3)	And lastly startCheckClassOnHour – which sets up the checks to be prefromed automatically every hour.
So the check time button, sets the automatic process of times checking once the server is up and running. If the server stops, the process will be halted and dates won’t be updated.
A user with a teachers permission:
If a user with a teachers permission logs in, they will see a teachers tab in the header links. On this page, the user can manipulate the timetable with their teachers perks. They can create a new class by filling out the: Class title, class description, the class capacity, if the class is active and choose themselves as the teacher (only themselves!). Then once they click create class, the new class object is created and can be added to the timetable.
Next the user sees the same timetable as other users, however if they click on occupied slots and they are not the teacher for that class, all they see is the class details and how many users are booked in. If they are the teacher for the class, they have the option to delete the class and all associated entries. This removes the class from the timetable. And lastly, if the user clicks on an empty slot, they will have an option to book a class for that day/time slot by choosing a class that they teach (other are not available). The club/ Day/ time are automatically filled based on the selected slot.
Admin user:
Users with full admin power, will have one more option in the header of the page – admin page, which just leads the user into the Django instance of admin interface. If the admin goes into the teachers tab, they have a class booking option with dropdowns. In this case, the user gets all times and days and can book whichever class into the timetable. If the slot is free, the new entry will be created. If the slot is occupied by another class, a prompt comes up stating that the slot is occupied and asking the user if they want to overwrite the class entry. If the user clicks yes – the old class is deleted and the new class is created in its stead.
The create a new class option is the same as for the teacher users, apart from the user being able to select any user as the teacher for the new class. This creates a new class and assigns the new user as the teacher.
If an admin user clicks on any occupied slot in the timetable, the popup will have an option to delete the class (regardless if admin is the teacher or not). If the admin clicks on the empty slot, they can then create a new booking and choose any class for that slot (regardless of who the teacher is).
And the last function on the page lets the admin to quickly populate the whole timetable with the same class. This was created to test various functions of the timetable instance.
Other functions:
Notification function:
If a user is on a waiting list and someone leaves the booking list, the next user in the waiting list gets a notification that lets them book into the class. As a placeholder occupies the freed up slot, only the user that was notified can book in and replace the placeholder.
The waiting list function is quite complex and works behind the scenes. If the class is fully booked, the users join the waiting list and are notified if a slot becomes available, giving them priority to swipe the booking.
The way it works:
Whenever a user that is booked into the class cancels, their slot in the booking is replaced by a placeholder (up to 3 placeholders for 3 slots, if there are more, the slot is freed up without creating a placeholder making it available for all). This placeholder (token1, token2, token3) consists of three user slots: user1, user2, user3. When a placeholder is first created, the first user on the waiting list que for that class is added as user1. This user then gets a notification that lets them book into the class on priority. When the placeholder is first created, a timer is set up, which if in 30 minutes user1 doesn’t take the booking slot, opens up to the next user on the waiting list in the following que position and is saved in user2. This user is also notified and can book into the class via the notification. The next timer then starts, notifying the next person In the que and adding them to user3. After that, the last timer is set for 3 minutes and once they are up, everyone on the waiting list is notified and can take the slot. The timer times can be adjusted to whichever preference. In order to test the functions they were set to 30 seconds.
Since there are 3 tokens, then it gets a bit more complex. Token one can only have waiting list que user 1(WL_user1), WL_user2, WL_user3. Token2 however starts the count from WL_user2, then 3, then 4 and Token3 – WL_user3 then 4, then 5 (assuming there are enough people on the waiting list, if not those user slots are set to none). The algorithm is set up to check which user takes the booking, check their position in the token user slots and update all following slots / tokens. The token where the user is in highest priority, is deleted to free up the booking. The timers that check for the waiting list entries are reset (and also started whenever a user joins the waiting list). Once a placeholder token is used for the booking, the booking is changed to hold the user instead of token user, the notifications for the users in the token users que are deleted and new notifications are sent out unless they already exist (to users that are part of other tokens).
This way the Waiting list function creates order and gives priority to all users. Last thing to note, 12 hours before the class starts, placeholder tokens are no longer created, so whenever a user leaves the class, the booking capacity is updated accordingly and any user can book in.


The models.py contains 12 models that are relevant to storing data in the database.

User - default user with the extra of a teacher specification
Profile - that again connects the user and a teacher boolean (true if teacher)
Fit_class - a fitness class object with a title, description, capacity, if its active, and who the teacher is(foreign key user)
Club - club entries in the systen, with its name and openning times. (was addedd to track if the club is closed/ open)
Day - an object to track which day of the week the class is on and has a timestamp (which is set based on the day of the week - Monday 1, Tuesday 2, wednsday 3 and st.) and a timestamp with the date of the class (future / present)
Time - time object that tracks each hour the classess are running. Similarly keeps track of the dates and times of the classes.
Timetable - Is a timetable instance that uses the class name, time slot, day and club. It also tracks the capacity for the class and is unique.
Booking - tacks what user is booked in for specific classes.
Waiting_List - tracks which user is in the que for the specific class and what is their position in the que.
Favorites - tracks which class the user added to their favorites list
Notifications - tracks what notifications the user has and for which class
And lastly Placeholder - tracks which class has placeholder tokens, which users have priority in the placeholder, tracks the timestamp of when the last user was notified and if the placeholder is open to all users on the waiting list. It also has its own function, which checks if the user is in one of the user positions. 
